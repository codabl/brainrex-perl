=begin comment

Brainrex API Explorer

Welcome to the Brainrex API explorer, we make analytics tools for crypto and blockchain. Our currently propiertary models offer sentiment analysis, market making, blockchain monitoring and face-id verification. This AI models can be consumed from this API. We also offer integrations to open data and propietary data providers, as well as free test data we collect. There is a collection of data transformation tools. Join our Telegram group to get the latest news and ask questions [https://t.me/brainrex, #brainrex](https://t.me/brainrex). More about Brainrex at [https://brainrex.com](http://brainrex.com). Full Documentation can be found at [https://brainrexapi.github.io/docs](https://brainrexapi.github.io/docs)

OpenAPI spec version: 0.1.1
Contact: support@brainrex.com
Generated by: https://github.com/swagger-api/swagger-codegen.git

=end comment

=cut

#
# NOTE: This class is auto generated by the swagger code generator program. 
# Do not edit the class manually.
# Ref: https://github.com/swagger-api/swagger-codegen
#
package WWW::SwaggerClient::CryptoApi;

require 5.6.0;
use strict;
use warnings;
use utf8; 
use Exporter;
use Carp qw( croak );
use Log::Any qw($log);

use WWW::SwaggerClient::ApiClient;

use base "Class::Data::Inheritable";

__PACKAGE__->mk_classdata('method_documentation' => {});

sub new {
    my $class = shift;
    my $api_client;

    if ($_[0] && ref $_[0] && ref $_[0] eq 'WWW::SwaggerClient::ApiClient' ) {
        $api_client = $_[0];
    } else {
        $api_client = WWW::SwaggerClient::ApiClient->new(@_);
    }

    bless { api_client => $api_client }, $class;

}


#
# exchanges_download_candles
#
# Downloads candle format market data
# 
# @param Request2 $request Person to create (required)
{
    my $params = {
    'request' => {
        data_type => 'Request2',
        description => 'Person to create',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'exchanges_download_candles' } = { 
    	summary => 'Downloads candle format market data',
        params => $params,
        returns => 'InlineResponse201',
        };
}
# @return InlineResponse201
#
sub exchanges_download_candles {
    my ($self, %args) = @_;

    # verify the required parameter 'request' is set
    unless (exists $args{'request'}) {
      croak("Missing the required parameter 'request' when calling exchanges_download_candles");
    }

    # parse inputs
    my $_resource_path = '/download_candles';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'request'}) {
        $_body_data = $args{'request'};
    }

    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('InlineResponse201', $response);
    return $_response_object;
}

#
# exchanges_list
#
# The markets data structure supported by the Brainrex Market API
# 
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'exchanges_list' } = { 
    	summary => 'The markets data structure supported by the Brainrex Market API',
        params => $params,
        returns => 'ARRAY[object]',
        };
}
# @return ARRAY[object]
#
sub exchanges_list {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/markets';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[object]', $response);
    return $_response_object;
}

#
# exchanges_marketmaker
#
# Market Making as a Service API.
# 
# @param Request3 $request Name of exchange and currency pair you want to provide liquidity (required)
{
    my $params = {
    'request' => {
        data_type => 'Request3',
        description => 'Name of exchange and currency pair you want to provide liquidity',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'exchanges_marketmaker' } = { 
    	summary => 'Market Making as a Service API.',
        params => $params,
        returns => 'InlineResponse2011',
        };
}
# @return InlineResponse2011
#
sub exchanges_marketmaker {
    my ($self, %args) = @_;

    # verify the required parameter 'request' is set
    unless (exists $args{'request'}) {
      croak("Missing the required parameter 'request' when calling exchanges_marketmaker");
    }

    # parse inputs
    my $_resource_path = '/market_making';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'request'}) {
        $_body_data = $args{'request'};
    }

    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('InlineResponse2011', $response);
    return $_response_object;
}

#
# exchanges_read
#
# The exchanges data structure supported by the Brainrex API
# 
{
    my $params = {
    };
    __PACKAGE__->method_documentation->{ 'exchanges_read' } = { 
    	summary => 'The exchanges data structure supported by the Brainrex API',
        params => $params,
        returns => 'ARRAY[object]',
        };
}
# @return ARRAY[object]
#
sub exchanges_read {
    my ($self, %args) = @_;

    # parse inputs
    my $_resource_path = '/exchanges';

    my $_method = 'GET';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('ARRAY[object]', $response);
    return $_response_object;
}

#
# exchanges_ticker_data_download
#
# Download raw ticker data from major crypto markets
# 
# @param Request1 $request Person to create (required)
{
    my $params = {
    'request' => {
        data_type => 'Request1',
        description => 'Person to create',
        required => '1',
    },
    };
    __PACKAGE__->method_documentation->{ 'exchanges_ticker_data_download' } = { 
    	summary => 'Download raw ticker data from major crypto markets',
        params => $params,
        returns => 'InlineResponse201',
        };
}
# @return InlineResponse201
#
sub exchanges_ticker_data_download {
    my ($self, %args) = @_;

    # verify the required parameter 'request' is set
    unless (exists $args{'request'}) {
      croak("Missing the required parameter 'request' when calling exchanges_ticker_data_download");
    }

    # parse inputs
    my $_resource_path = '/download_ticker';

    my $_method = 'POST';
    my $query_params = {};
    my $header_params = {};
    my $form_params = {};

    # 'Accept' and 'Content-Type' header
    my $_header_accept = $self->{api_client}->select_header_accept('application/json');
    if ($_header_accept) {
        $header_params->{'Accept'} = $_header_accept;
    }
    $header_params->{'Content-Type'} = $self->{api_client}->select_header_content_type('application/json');

    my $_body_data;
    # body params
    if ( exists $args{'request'}) {
        $_body_data = $args{'request'};
    }

    # authentication setting, if any
    my $auth_settings = [qw()];

    # make the API Call
    my $response = $self->{api_client}->call_api($_resource_path, $_method,
                                           $query_params, $form_params,
                                           $header_params, $_body_data, $auth_settings);
    if (!$response) {
        return;
    }
    my $_response_object = $self->{api_client}->deserialize('InlineResponse201', $response);
    return $_response_object;
}

1;
